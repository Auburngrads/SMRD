# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

ALTSIM <- function(x, y, cen, wt, nrow, nter, ny, nty, ty, tcodes, kdist, gamthr, lfix, nparm, intcpt, escale, e, maxit, kprint, dscrat, iscrat, devian, thetah, fsder, vcv, r, res, fv, theta, xnew, ynew, centim, acvar, nsubex, nacvar, nsamsz, krfail, kctype, retmat, numret, numsim, iersim) {
    .Call(`_SMRD2_ALTSIM`, x, y, cen, wt, nrow, nter, ny, nty, ty, tcodes, kdist, gamthr, lfix, nparm, intcpt, escale, e, maxit, kprint, dscrat, iscrat, devian, thetah, fsder, vcv, r, res, fv, theta, xnew, ynew, centim, acvar, nsubex, nacvar, nsamsz, krfail, kctype, retmat, numret, numsim, iersim)
}

#' Simulate the alt data
wqm_simalt <- function(theta, nparm, intcpt, nsamsz, krfail, kctype, centim, acvar, nsubex, nacvar, kdist, x, y, cen, wt, nrow, nter, ny, nty, ty, tcodes, nrownw, iersim, kprint) {
    .Call(`_SMRD2_wqm_simalt`, theta, nparm, intcpt, nsamsz, krfail, kctype, centim, acvar, nsubex, nacvar, kdist, x, y, cen, wt, nrow, nter, ny, nty, ty, tcodes, nrownw, iersim, kprint)
}

#' Generate accelerated life test plans with specified characteristics.
#'
#' @name aplan
#'
#' @param ap Standardized intercept
#' @param bp Standardized slope = (muh-mud)/sigmad;
#' @param thet1p theta1 = sigmah/sigmad;
#' @param pvalp Percentile of interest
#' @param knownp \code{integer} specifying type of model (see details)
#' @param idistp equals 1 for SEV/Weibull, 2 for Normal/Lognormal
#' @param ioptsp option for lower stress (see details)
#' @param ioptap option for allocation (see details)
#' @param ioptmp option for the middle stress level (see details)
#' @param pifixp middle allocation when ioptap=3
#' @param zholdp fixed value of z when ioptsp=3
#' @param pmlimp lower bound on pm when ioptmp=2
#' 
#' @return
#'   \code{zp}     Length-3 vector of standardized stress levels
#'   \code{pip}    Length-3 vector of proportionate allocations;
#'   \code{fpp}    Length-3 vector of failure probabilities;
#'   \code{pqp}    Length-3  vector equal to pip * fp
#'   \code{var}    Variance of yhat(pvalp)
#'   \code{iprinp} Level of printing (0 for none, 4 for debug)
#' 
#' @details 
#' \code{knownp} = 1 for unknown theta1, 
#'                 2 for known theta1,
#'                 3 for constant sigma quadratic model.
#' \code{ioptsp} = 1 set low stress such that pmlim is failure prob at zl
#'                 2 optimize low stress level,
#'                 3 set low stress such that zl=zholdp
#'                 4 optimize low and middle stress levels
#' \code{ioptap} = 1 equal allocation
#'                 2 equal expected number failing
#'                 3 optimize with fixed pim
#'                 4 optimize with e(rl)=r(rm);
#'                 5 optimize with e(rm)=r(rh);
#'                 6 4 2 1 relative allocation;
#'                 7 1 2 2 relative expected failures;
#'                 8 1 2 3 relative expected failures;
#'                 9 optimize low and middle;
#'                 10 optimize with pim=pih (as suggested by Wayne N.)
#' \code{ioptmp} = 0 xm=(xl+xh)/2
#'                 1 fm=(fl+fh)/2
#'                 2 xm=(xl+xh)/2 if fm>pmlim and fm=pmlim otherwise
#'                 3 float                 
APLAN <- function(ap, b1p, b2p, thet1p, pvalp, knownp, idistp, ioptsp, ioptap, ioptmp, pifixp, zholdp, pmlimp, zp, pip, fpp, pqp, var, iprinp, ier) {
    .Call(`_SMRD2_APLAN`, ap, b1p, b2p, thet1p, pvalp, knownp, idistp, ioptsp, ioptap, ioptmp, pifixp, zholdp, pmlimp, zp, pip, fpp, pqp, var, iprinp, ier)
}

#' Fix lower cdf confidence limits to be monotone
#' 
#' @name bfixl
BFIXL <- function(vec) {
    .Call(`_SMRD2_BFIXL`, vec)
}

#' Fix upper cdf confidence limits to be monotone
#' 
#' @name bfixu
BFIXU <- function(vec) {
    .Call(`_SMRD2_BFIXU`, vec)
}

#'  #***see comments at top of genmax for description of the first
#'  #***arguments of this subroutine
#'     #it looks like ti is necessary to sned down the
#'     scaled information as well as the scaled and transformed
#'     x and y. 
#'  #
#'  #
#'  #
#'  #
#'  #conlev      (I)  confidence level as a probability (e.g.0.95)
#'  #
#'  #
#'  #
#'  #kodef      (I but should be O!)   range kode for the function to be computed
#'  #                1    -infinity to +infinity
#'  #                2     greater than zero
#'  #                3     between 0 and 1
#'  #
#'  #
#'  #
#'  #fargv(nargv)  (I) double precision vector of arguments for the
#'  #                  function (e.g.times for failure probabilities
#'  #                  or probs for quantiles)
#'  #
#'  #
#'  #nargv      (I)   length of fargv (should be 0 if no argument)
#'  #
#'  #
#'  #
#'  #kfuncp    (I)    function number
#'  #              x1  failure probability
#'  #              x2  distribution quantile
#'  #              x3  hazard rate
#'  #            >100  user specified
#'  #
#'  #        for more complicated models (e.g., model 1, 2, or 3)
#'  #        x is the subpopulation number (0 for entire population)
#'  #
#'  #
#'  #
#'  #  kpopu    (I)  for mixtures, specifies which population for quantiles
#'  #                 failure probs, etc.
#'  #
#'  #
#'  #kpoint    (I)    row number for getting explanatory variable conditions
#'  #                 send down kpoint=1 if no regression
#'  #
#'  #
#'  #vcvs(nparm,nparm) (I)  double precision covariance matrix of thetas
#'  #
#'  #
#'  #epsxp     (I)    double precision epsilon for finite differences
#'  #                 if zero is sent down, 1.0d-08 is used (now hardwired)
#'  #
#'  #
#'  #fest(nargv)   (O)  estimates of function
#'  #
#'  #stderr(nargv) (O)  estimated standard error of fest
#'  #
#'  #xlow(nargv)   (O)  lower confidence bounds
#'  #
#'  #xup(nargv)    (O)  upper confidence bound
GENFUN <- function(kmod, kdist, ilabp, ilabd, theta, thetas, kodet, ifix, nparm, npard, y, ncoly, nrownw, x, ncolx, codes, weight, ty, ncolty, tcodes, kprint, kparv, nrvar, mrelat, nrelat, mnrvar, conlev, kodef, fargv, nargv, kfuncp, kpopu, kpoint, vcvs, fest, std_err, xlow, xup, nxd, intd, ipxcd, irelad, ier, llog, kmodp, maxpd, nregr, kmccde, pfail, npardm, nnum, kparm, iup, nterd) {
    .Call(`_SMRD2_GENFUN`, kmod, kdist, ilabp, ilabd, theta, thetas, kodet, ifix, nparm, npard, y, ncoly, nrownw, x, ncolx, codes, weight, ty, ncolty, tcodes, kprint, kparv, nrvar, mrelat, nrelat, mnrvar, conlev, kodef, fargv, nargv, kfuncp, kpopu, kpoint, vcvs, fest, std_err, xlow, xup, nxd, intd, ipxcd, irelad, ier, llog, kmodp, maxpd, nregr, kmccde, pfail, npardm, nnum, kparm, iup, nterd)
}

#' New version that sends down arrays instead of pointers!!
#'
#'  #  kmod           (I)  model code (usual list 1-5)
#'  #  -------------------------------------------------------------
#'  #    0  distribution kdist with one or more parameters related to
#'  #       explanatory variables
#'  #    1  same as 0 with an lfp parameter
#'  #    2  same as 0 with a doa parameter
#'  #    3  steady-state model with distribution kdist plus exponential
#'  #       competing risk
#'  #    4  proportional hazards model for distribution kdist plus
#'  #       explanatory variables for the power (or other) parameters
#'  #
#'  #  kdist         (I)   distribution number (usual list 1-12)
#'  #                   >100 is a user specified distribution
#'  #
#'  #  theta(nparm)   (O)   double precision vector returning ml estimates
#'  #                      of model parameters and values of any
#'  #                      fixed parameters
#'  #
#'  #  thetas(nparm) (O)   double precision vector returning ml
#'  #                      scaled estimates
#'  #                   of model parameters and (scaled) values of
#'  #                   any fixed parameters
#'  #                   data scaled according to centered and scaled x
#'  #
#'  #  kodet(nparm)  (O)   integer vector of parameter codes indicating range
#'  #                        0 fixed
#'  #                        1 unrestricted
#'  #                        2 positive
#'  #                        3 0-1
#'  #
#'  #
#'  #  ifix(nparm)   (I)   an integer vector of 0's and 1's to indicate which
#'  #                   parameters are to be fixed (1 for fixed)
#'  #
#'  #  nparm       (O)     number of model parameters
#'  #                   nparm is the sum of the parameters in all of the
#'  #                   regression relationships plus any model parameters
#'  #                   that do not depend on explanatory variables
#'  #                   If this number is needed above before calling
#'  #                   genmax (to allocate parameter space) it can be
#'  #                   gotten from a call to gensiz
#'  #                   the model stuff (kmod,kdist,kparv,nrvar,mrelat,nrelat)
#'  #                   has been set.
#'  #
#'  #  npard       (O)     number of model parameters
#'  #                   npard is the  number of parameters in the distributional
#'  #                   model (i.e., for a particular combination of the
#'  #                   explanatory variables
#'  #                   If this number is needed above before calling
#'  #                   genmax (to allocate parameter space) it can be
#'  #                   gotten from a call to gensiz
#'  #                   the model stuff (kmod,kdist,kparv,nrvar,mrelat,nrelat)
#'  #                   has been set.
#'  #
#'  #  y            (I)  real matrix of response times .
#'  #                      transformed times may be returned
#'  #
#'  #  ncoly        (I)    number of columns in the observation matrix (1 or 2)
#'  #
#'  #  nrownw        (I)     number of rows in the data matrix
#'  #
#'  #  x         (I)     real matrix x of explanatory variables
#'  #                      which  must have a
#'  #                      column of ones in the first column (even if it
#'  #                      is not used).
#'  #
#'  #               *****  note that upon return, x may not be in its original
#'  #                      form due to scaling or other standardization.
#'  #
#'  #  ncolx         (I)   number of columns in x, not including the required col
#'  #                      of ones (because we think of the ones as column zero)
#'  #
#'  #  codes         (I)  real vector of censor codes
#'  #
#'  #  weight        (I)   real vector of observation weights
#'  #
#'  #  ty          (I)   real matrix of truncation times
#'  #
#'  #  ncolty       (I)    number of columns in the matrix of truncation times
#'  #                      (0, 1, or 2)
#'  #
#'  #  tc           (I)  real vector of truncation codes
#'  #
#'  #  kprint       (I)    print code 0-none  1-minimal 2-usual 3-light debug
#'  #                   4 and higher provides more debug output
#'  #
#'  #
#'  #  kparv        (I) integer vector giving parameter
#'  #                   numbers having regression
#'  #                   relationships
#'  #
#'  #  nrvar      (I)   integer vector. nrvar(i) gives the number of columns
#'  #                   of x that are in the relationship for the
#'  #                   parameter specified in kparv(i)
#'  #
#'  #  mrelat(mnrvar,nrelat)  (I) integer matrix
#'  #                   in which entry i,j gives the col of x
#'  #                   for the ith term of the jth relationship.  i=1,nrvar(j),
#'  #                   j=1,nrelat
#'  #
#'  #  nrelat     (I) number of regression relationships
#'  #
#'  #  mnrvar     (I)   integer vector. nrvar(i) gives the number of columns
#'  #
#'  #  xlogl        (O) double precision scaler returning value of the
#'  #                   log likelihood
#'  #
#'  #  yhat       (O) real vector (matrix) of fitted values (same size as y)
#'  #
#'  #  resid       (O) real vector  (matrix) of residuals (same size as y)
#'  #
#'  #  vcv(nparm,nparm) (O) double precision matrix returning estimated matrix of
#'  #                   variances and covariances of the ml estimates
#'  #
#'  #  vcvs(nparm,nparm)(O)  double precision matrix returning estimated
#'  #                        matrix of variances and covariances of the
#'  #                        ml scaled estimates
#'  #
#'  #  r(nparm,nparm)   (O)  double precision matrix returning estimated
#'  #                        correlation  matrix from the vcv matrix
#'  #
#'  # start           (I--opt)  optional vector of starting parameter values
#'  #                       (ignored if lstar=0)
#'  #
#'  # lstar            (I)    =1 is start values are in start
#'  #                         =0 if automatic start values are
#'  #                             to be computed velow
#'  #
#'  # ilabp           (O)  integer vector of parameter labels (length 8*nparm)
#'  #                      in this new version we copy over to stack and pass
#'  #                      pointers below
#'  #
#'  # ilabd           (O)  integer vector of distribution parmameters
#'  #                      (length 8*nparm)
#'  #                      in this new version we copy over to stack and pass
#'  #                      pointers below
#'  #
#'  #  ier            code       meaning
#'  #     -------------------------------------------------------------------
#'  #     third digit:  0 no optimization errors detected
#'  #                   1 likelihood shape caused problems with the powell alg
#'  #                   2 convergence criterion not met after maximum number
#'  #                     or iterations
#'  #
#'  #   second digit:   0 first derivatives of likelihood small
#'  #                   1 first derivatives of the loglikelihood too large
#'  #
#'  #    first digit:   0 estimated fisher info matrix inverted successfully
#'  #                   1 estimated fisher info matrix appears to be singular
#'  #
#'  #note: all pointers sent down in the argument list are pointing to the
#'  #     rs(.) stack in labeled common.
#'  #
#'  #      fortran typing conventions are generally followed for typing
#'  #      except that double precision is used except when data is to
#'  #      be taken from the worksheet.
GENMAX <- function(kmod, kdist, theta, thetas, kodet, ifix, nparm, npard, y, ncoly, nrownw, x, ncolx, codes, weight, ty, ncolty, tcodes, kprint, kparv, nrvar, mrelat, nrelat, mnrvar, xlogl, yhat, resid, vcvs, vcv, r, start, lstar, conlev, ilabp, ilabd, ier, nxd, intd, ipxcd, irelad, fstder, nregr, kcentr, kpoint, ifit, kgtall, llog, kmodp, maxit, pest, epsx, npardm, nnum, kparm, iup, nterd, maxpd, pfail, kmccde, nstart, maxmsd, tol, lsd, pchmax) {
    .Call(`_SMRD2_GENMAX`, kmod, kdist, theta, thetas, kodet, ifix, nparm, npard, y, ncoly, nrownw, x, ncolx, codes, weight, ty, ncolty, tcodes, kprint, kparv, nrvar, mrelat, nrelat, mnrvar, xlogl, yhat, resid, vcvs, vcv, r, start, lstar, conlev, ilabp, ilabd, ier, nxd, intd, ipxcd, irelad, fstder, nregr, kcentr, kpoint, ifit, kgtall, llog, kmodp, maxit, pest, epsx, npardm, nnum, kparm, iup, nterd, maxpd, pfail, kmccde, nstart, maxmsd, tol, lsd, pchmax)
}

#' Perform ml estimation and find vcvs and correlation matrices
NULL

#' Compute the sizes of parameter vectors
#' 
#' @description Given model information compute nparm and 
#'              npard giving the sizes of parameter vectors.
#'              
#' @param kmod Integer model code (see Details)
#' @param kdist Integer code representing distribution number 
#'              usually in 1-12. \code{kdist > 100}> signifies
#'              a user specified distribution.
#' @param kparv Integer vector giving parameter numbers 
#'              that have regression relationships.
#' @param nrvar Integer vector. \code{nrvar[i]} gives the number of 
#'              columns in the x-matrix that are in the relationship 
#'              for the parameter specified in \code{kparv[i]}.
#' @param mrelat Integer matrix with dimensions [mnrvar,nrelat]  
#'               in which \code{mrelat[i,j]} gives the col of 
#'               the x-matrix for the ith term of the jth relationship.  
#'               \code{i = 1,nrvar[j], j = 1,nrelat} (see Details).
#' @param nrelat Integer giving the number of regression relationships
#' @param mnrvar Integer giving the number of columns in the x-matrix
#'               \code{mnrvar = max(nrvar)}.
#' @param ncolx  Integer giving the number of columns in the x-matrix. This does not include
#'               the required column of ones (we think of the ones as column zero).
#' @param kprint Integer giving the print code for debugging output (see Details).
#' @param nparm  Integer giving the sum of the parameters in all of the regression 
#'               relationships plus any model parameters that do not depend on 
#'               explanatory variables.
#' @param npard  Integer giving the number of parameters in the distributional
#'               model (i.e., for a particular combination of the explanatory 
#'               variables.
#' @param ier Three-digit integer giving error codes upon return (see Details)
#' @param nxd Integer vector (length = 5) giving the number of dimensions in the x-matrix for each relationship
#' @param intd Integer vector (length = 5) giving the number of relationships with an intercept term
#' @param ipxcd Integer vector (length = 5) giving the columns in the x-matrix that are involved with each relationship
#' @param irelad Integer vector (length = 5) giving the number of things (don't know yet). 
#' @param ilabp Integer vector of parameter labels (length 8*nparm) in this new 
#'        version we copy over to stack and pass pointers below.
#' @param ilabd Integer vector of distribution parmameters (length 8*nparm)
#'              in this new version we copy over to stack and pass 
#'              pointers below.
#' @details See Rcpp function \code{genmax} for more information 
#'          on parameters than what is shown here.
#'          
#'          \code{kmod} values:
#'          \describe{
#'           \item{0}{Distribution \code{kdist} with one or more parameters related to
#'                    explanatory variables.}
#'           \item{1}{Same as \code{kmod = 0} with an lfp parameter.}
#'           \item{2}{Same as \code{kmod = 0} with a doa parameter.}
#'           \item{3}{Steady-state model with distribution \code{kdist} plus
#'                    exponential competing risk.}
#'           \item{4}{Proportional hazards model for distribution \code{kdist} 
#'                    plus explanatory variables for the power (or other) parameters.}
#'          }
#'          
#'          Columns in the x-matrix may have a functional relationship
#'          with the location parameter, the scale parameter, or another model
#'          parameter. Each column in the matrix \code{mrelat} gives which columns
#'          in the x-matrix are related to a specific parameter.  If all columns
#'          in the x-matrix are related to the location parameter only one column
#'          in \code{mrelat} will contain non-zero elements.
#'          
#'          \code{kprint} values:
#'          \describe{
#'           \item{0}{no printing at all}
#'           \item{1}{minimal printing}
#'           \item{2}{usual printing - no debugging}
#'           \item{3}{light debugging}
#'           \item{4+}{heavy debugging}
#'          }
#'          
#'          \code{ier} error code values:
#'          \itemize{
#'           \item{third digit:
#'             \describe{
#'              \item{0}{No optimization errors detected}
#'              \item{1}{Likelihood shape caused problems with the powell alg}
#'              \item{2}{Convergence criterion not met after maximum number of iterations}
#'             }
#'             }
#'             \item{second digit:
#'              \describe{
#'               \item{0}{first derivatives of likelihood small}
#'               \item{1}{first derivatives of the loglikelihood too large}
#'              }
#'              }
#'              \item{
#'               \describe{
#'               \item{0}{estimated fisher info matrix inverted successfully}
#'               \item{1}{estimated fisher info matrix appears to be singular}
#'               }
#'              }
#'          }
GENSIZ <- function(kmod, kdist, kparv, nrvar, mrelat, nrelat, mnrvar, ncolx, kprint, nparm, npard, ier, nxd, intd, ipxcd, irelad, ilabp, ilabd, nregr, kgtall, llog, kmodp, npardm, nnum, kparm, iup, nterd, maxpd) {
    .Call(`_SMRD2_GENSIZ`, kmod, kdist, kparv, nrvar, mrelat, nrelat, mnrvar, ncolx, kprint, nparm, npard, ier, nxd, intd, ipxcd, irelad, ilabp, ilabd, nregr, kgtall, llog, kmodp, npardm, nnum, kparm, iup, nterd, maxpd)
}

#' Meeker-LuValle Model 1
#' 
#' @name mlmod1
#' 
#' @description Compute growth of filament according 
#'              to Meeker-LuValle Model 1 different 
#'              rate parameter at each time interval
MLMOD1 <- function(times, number_times, a2_init, a2_limit, rate, rate_factor, a2) {
    .Call(`_SMRD2_MLMOD1`, times, number_times, a2_init, a2_limit, rate, rate_factor, a2)
}

#'                     method 2
#'
#'                      nonparametric          parametric
#'
#'method 2 simulation---nonparametric sampling/parametric inference
#'
#'must send down a complete data set
#'
#'    parameter meanings same as in wqm_mlboth except the following:
#'
#'    can get rid of scalars like iervcv,ierfit,xlike,nobs
#'
#'theta(nparm)   true value of theta
#'
#'thetah(nparm)     space for thetahat
#'
#'iarray(marray)    scratch  space needed to generate random weights
#'
#'marray            length of scratch space. must be at least equal
#'                  in length to the number of rows in wt
#'                  a computationally more efficient method is used
#'                  if the number is larger than the sum of the weights
#'
#'wtnew             vector for the random weights for the simulation
#'
#'xnew              hold space for x
#'
#'ynew             hold space for y
#'
#'iret    amount of stuff to return
#'
#'retmat(numret,numsim)  matrix to return the results, one result per col
#'
#'numsim  number of simulations to be run
#'
#'nrowr   number of rows being returned in retmat
#'
#'tspass(33)  should be able to eliminate
#'
#'lrand     should be able to eliminate
#'
#'
#'iersim  data space too small
#'
#'   need to send down data space big enough to cover all data situations
#'
MLSIM2 <- function(x, y, cen, wt, nrow, nter, ny, nty, ty, tcodes, kdist, gamthr, lfix, nparm, intcpt, escale, e, maxit, kprint, dscrat, iscrat, devian, thetah, fsder, vcv, r, res, fv, theta, iarray, marray, wtnew, xnew, ynew, iret, retmat, numsim, numret, tspass, lrand, iersim) {
    .Call(`_SMRD2_MLSIM2`, x, y, cen, wt, nrow, nter, ny, nty, ty, tcodes, kdist, gamthr, lfix, nparm, intcpt, escale, e, maxit, kprint, dscrat, iscrat, devian, thetah, fsder, vcv, r, res, fv, theta, iarray, marray, wtnew, xnew, ynew, iret, retmat, numsim, numret, tspass, lrand, iersim)
}

MLSIM3 <- function(y, cen, wt, nrow, ny, nty, ty, tcodes, gamthr, maxit, kprint, dscrat, iscrat, scrat, p, q, prob, sd, m, pnew, qnew, prbnew, sdnew, iarray, marray, wtnew, ynew, retmat, numsim, numret, tspass, lrand, iersim) {
    .Call(`_SMRD2_MLSIM3`, y, cen, wt, nrow, ny, nty, ty, tcodes, gamthr, maxit, kprint, dscrat, iscrat, scrat, p, q, prob, sd, m, pnew, qnew, prbnew, sdnew, iarray, marray, wtnew, ynew, retmat, numsim, numret, tspass, lrand, iersim)
}

MLSIM6 <- function(x, y, cen, wt, nrow, nter, ny, nty, ty, tcodes, kdist, gamthr, lfix, krfail, nparm, intcpt, escale, e, maxit, kprint, dscrat, iscrat, devian, thetah, fsder, vcv, r, res, fv, theta, retmat, numsim, prdelt, ngroup, centim, nsamsz, nmrvec, nsimg, numret, nnomle, iersim) {
    .Call(`_SMRD2_MLSIM6`, x, y, cen, wt, nrow, nter, ny, nty, ty, tcodes, kdist, gamthr, lfix, krfail, nparm, intcpt, escale, e, maxit, kprint, dscrat, iscrat, devian, thetah, fsder, vcv, r, res, fv, theta, retmat, numsim, prdelt, ngroup, centim, nsamsz, nmrvec, nsimg, numret, nnomle, iersim)
}

MLSIM7 <- function(x, y, cen, wt, nrow, nter, ny, nty, ty, tcodes, kdist, gamthr, lfix, krfail, nparm, intcpt, escale, e, maxit, kprint, dscrat, iscrat, devian, thetah, fsder, vcv, r, res, fv, theta, retmat, numsim, prdelt, ngroup, centim, nsamsz, nmrvec, nsimg, numret, nnomle, iersim) {
    .Call(`_SMRD2_MLSIM7`, x, y, cen, wt, nrow, nter, ny, nty, ty, tcodes, kdist, gamthr, lfix, krfail, nparm, intcpt, escale, e, maxit, kprint, dscrat, iscrat, devian, thetah, fsder, vcv, r, res, fv, theta, retmat, numsim, prdelt, ngroup, centim, nsamsz, nmrvec, nsimg, numret, nnomle, iersim)
}

MLSIM8 <- function(x, y, cen, wt, nrow, nter, ny, nty, ty, tcodes, kdist, gamthr, lfix, krfail, nparm, intcpt, escale, e, maxit, kprint, dscrat, iscrat, devian, thetah, fsder, vcv, r, res, fv, theta, retmat, numsim, prdelt, ngroup, centim, nsamsz, nmrvec, nsimg, numret, nnomle, iersim) {
    .Call(`_SMRD2_MLSIM8`, x, y, cen, wt, nrow, nter, ny, nty, ty, tcodes, kdist, gamthr, lfix, krfail, nparm, intcpt, escale, e, maxit, kprint, dscrat, iscrat, devian, thetah, fsder, vcv, r, res, fv, theta, retmat, numsim, prdelt, ngroup, centim, nsamsz, nmrvec, nsimg, numret, nnomle, iersim)
}

#'  Compute the nonparametric estimate of the
#'  mean cumulative occurence rate of failures
#'  and corresponding estimate of the var if the estimator
#' 
#' 
#'   inputs:
#'         itime(nobs)       time indices   (from 1,2,..., nfailt)
#'                           gives index pointing to the vector of unique times
#'         isys(nobs)         system indices (from 1,2,..., nsys)
#'                           gives index pointing to the vector of unique sys ids
#'         icodes(nobs)       censor/failure indicator (1 fail, 2 censor)
#'         weight(nobs)       weight (multiplicity) or cost of failure
#'         nobs               number of observations in data set
#'         nfailt             number of unique failure times
#'         nsys               number of unique system ids
#'         utime(nfailt)     list of unique times
#'         iusys(nsys)        list of unique system ids
#' 
#' 
#' 
#'         ctime(nsys),varsum(nsys) scratch arrays
#'         dead(nfailt,nsys),idelta(nfailt,nsys) scratch arrays
#'         dsum(nfailt),idlsum(nfailt),dbar(nfailt)   scratch arrays
#' 
#' 
#'   outputs:
#'         xmuhat(nfailt)   estimate of mu at each failure time
#'         varxmu(nfailt)   estimate of var(muhat) at each failure time
NPSYS <- function(itime, isys, icodes, weight, nobs, nfailt, nsys, utime, iusys, ctime, dead, idelta, dsum, idlsum, dbar, varsum, xmuhat, varxmu, kprint) {
    .Call(`_SMRD2_NPSYS`, itime, isys, icodes, weight, nobs, nfailt, nsys, utime, iusys, ctime, dead, idelta, dsum, idlsum, dbar, varsum, xmuhat, varxmu, kprint)
}

#'  Compute empirical the predictive distributions 
#'  (pdf, cdf) for the kth order statistic in a 
#'  future sample.
#'  @name POSTKP
#'  
#' @param nsamsz The size of the future sample
#' @param kord The order statistic
#' @param xltime The time vector
#' @param ntvec The length of the tvector (at which evaluations will be done)
#' @param xmu The mu* values from the posterior sample 
#' @param sigma The sigma* values from the posterior sample
#' @param nsim The value M*
POSTKP <- function(kord, nsamsz, xltime, ntvec, xmu, sigma, nsim, kdist, pdf, cdf) {
    .Call(`_SMRD2_POSTKP`, kord, nsamsz, xltime, ntvec, xmu, sigma, nsim, kdist, pdf, cdf)
}

#' Compute empirical the predictive distributions 
#' (pdf, cdf) of a single future observation from 
#' distribution kdist
#' 
#' @name postpr
#' 
#' @param xltime The time vector
#' @param ntvec The length of the tvector (at which evaluations will be done
#' @param xmu The mu* values from the posterior sample 
#' @param sigma The sigma* values from the posterior sample
#' @param nsim The value M*
POSTPR <- function(xltime, ntvec, xmu, sigma, nsim, kdist, pdf, cdf) {
    .Call(`_SMRD2_POSTPR`, xltime, ntvec, xmu, sigma, nsim, kdist, pdf, cdf)
}

#' Does good stuff
#' 
#' @name prcs
PRCS <- function(zmax, z1, nsim, dvec, answer, nd) {
    .Call(`_SMRD2_PRCS`, zmax, z1, nsim, dvec, answer, nd)
}

#' Compute the risk set for a recurrence process within 
#' observation windows.
#' 
#' @name RISKSET
#' 
#' @description We want the number of units at risk 
#'              just before each event time it is 
#'              also possible to send down a longer 
#'              list of times for purposes of making 
#'              a riskset plot.
#' @param muniqrecurr number of unique recurrence times
#' @param tuniq length(muniqrecurr) unique recurrence 
#'        times (in increasing order);
#' @param nwindows length of twindowsl and twindowsu;
#' @param twindowsl vector giving observation window 
#'        start points
#' @param twindowsu window end points corresponding 
#'        to twindowsl
#' @param wcounts counts for the windows;
#' @param iordl scratch space ordering vector for twindowsl;
#' @param iordu scratch ordering vector for twindowsu;
#' 
#' @return delta length(muniqrecurr) size of the risk set 
#'         just before time tuniq(j)
#'         
#' @details Wrapper for wqm_riskset        
RISKSET <- function(muniqrecurr, tuniq, nwindows, twindowsl, twindowsu, wcounts, iordl, iordu, delta, kdebug, iscrat) {
    .Call(`_SMRD2_RISKSET`, muniqrecurr, tuniq, nwindows, twindowsl, twindowsu, wcounts, iordl, iordu, delta, kdebug, iscrat)
}

#' Wrapper for mapping beta to a quantile??? not clear why needed
SBQ <- function(ndist1, ndist2, stress, alpha, beta0, beta1, sigma, ugamma, sdgamma, bd1, bd2, quan, kprint) {
    .Call(`_SMRD2_SBQ`, ndist1, ndist2, stress, alpha, beta0, beta1, sigma, ugamma, sdgamma, bd1, bd2, quan, kprint)
}

#' Compute the probability that a bivariate normal with mean vectorc
SBVN <- function(ah, ak, xmu1, xmu2, v1, v2, c12, prob, n, kprint) {
    .Call(`_SMRD2_SBVN`, ah, ak, xmu1, xmu2, v1, v2, c12, prob, n, kprint)
}

#' compute the vector of nhpp mcf values
#' @name sfmcf
SFMCF <- function(time, kform, theta, ntimes, answer) {
    .Call(`_SMRD2_SFMCF`, time, kform, theta, ntimes, answer)
}

#' Does good stuff
#' @name sfteval
SFTEVAL <- function(kdmod, xmu2, sig2, xmu3, sig3, rho, df, d0, sfact, tf, number, answer, ier, kprint) {
    .Call(`_SMRD2_SFTEVAL`, kdmod, xmu2, sig2, xmu3, sig3, rho, df, d0, sfact, tf, number, answer, ier, kprint)
}

#' R interface for GENG cdf;
#' @name sgpdfl
SGPDFL <- function(tvec, gamme, maxlen, answer) {
    .Call(`_SMRD2_SGPDFL`, tvec, gamme, maxlen, answer)
}

#' R interface for GENG cdf
#' 
#' @name sgquan
SGQUAN <- function(pvec, gamme, maxlen, answer) {
    .Call(`_SMRD2_SGQUAN`, pvec, gamme, maxlen, answer)
}

#' Compute a vector of NHPP log likelihood values 
#' corresponding to a thetav matrix
#' @name sloglikenhpp
SLOGLIKENHPP <- function(time, ntimes, recurrcosts, timel, timeu, kwcount, nwindows, kform, thetav, nparm, ntheta, answer) {
    .Call(`_SMRD2_SLOGLIKENHPP`, time, ntimes, recurrcosts, timel, timeu, kwcount, nwindows, kform, thetav, nparm, ntheta, answer)
}

#' Does good stuff
#' @name slsinf
SLSINF <- function(idist, itype, zlv, zrv, f11, f12, f22, nrows, ifault, irow) {
    .Call(`_SMRD2_SLSINF`, idist, itype, zlv, zrv, f11, f12, f22, nrows, ifault, irow)
}

#' R interface for GENG cdf;
#' @name spgeng
SPGENG <- function(tvec, gamme, maxlen, answer) {
    .Call(`_SMRD2_SPGENG`, tvec, gamme, maxlen, answer)
}

#' R interface for gng log(1-cdf)
SPMLGENG <- function(tvec, gamme, maxlen, answer) {
    .Call(`_SMRD2_SPMLGENG`, tvec, gamme, maxlen, answer)
}

#' Vector version of urlike for R calling
SSFT2GR1 <- function(t, nt, r1log, mut2, sigmat2, mur1, sigmar1, mur2, sigmar2, rho, answer, kprint, ier) {
    .Call(`_SMRD2_SSFT2GR1`, t, nt, r1log, mut2, sigmat2, mur1, sigmar1, mur2, sigmar2, rho, answer, kprint, ier)
}

#' Vector version of urlike for Splus calling
SURLIKE <- function(t, nt, mut1, sigmat1, mut2, sigmat2, mur1, sigmar1, mur2, sigmar2, rho, answer, kprint) {
    .Call(`_SMRD2_SURLIKE`, t, nt, mut1, sigmat1, mut2, sigmat2, mur1, sigmar1, mur2, sigmar2, rho, answer, kprint)
}

SXCDF <- function(ndist1, ndist2, beta0, beta1, xstr, sigma, ugamma, sgamma, w, num, answer, ier) {
    .Call(`_SMRD2_SXCDF`, ndist1, ndist2, beta0, beta1, xstr, sigma, ugamma, sgamma, w, num, answer, ier)
}

SXPDF3 <- function(ndist1, ndist2, beta0, beta1, xstr, sigma, ugamma, sgamma, w, num, answer, ier, kprint) {
    .Call(`_SMRD2_SXPDF3`, ndist1, ndist2, beta0, beta1, xstr, sigma, ugamma, sgamma, w, num, answer, ier, kprint)
}

VAVAR <- function(idist, nrows, zc, ze, avar) {
    .Call(`_SMRD2_VAVAR`, idist, nrows, zc, ze, avar)
}

#' Vectorized version ov svar1
#' Calculate variance of percentile at some stress level
#' zivar is the variable defining that level
#' (usually set to zero for design stress)
#' this a wrap for a call from splus
VVAR1 <- function(param, z, pi, zivar, npar, nplan, nlev, perc, idist, knownt, fret, varret, iprint) {
    .Call(`_SMRD2_VVAR1`, param, z, pi, zivar, npar, nplan, nlev, perc, idist, knownt, fret, varret, iprint)
}

#' Compute Nonparametric CDF Estimates
#'
#' @name wqm_cdfest
#' @description Computes nonparametric estimates of the cumulative distribution function
#'              using maximum likelihood. If possible, estimation this is done with a
#'              generalized version of the Kaplan-Meier estimate, and otherwise, by using
#'              Turnbull's e-m algorithm
#' @param y Numeric matrix \code{[n x ny]} containing the lower and upper limits for group
#'          censored observations.
#' @param ny Number of columns in \code{y} (either 1 or 2)
#' @param codes Integer vector of censor codes (see Details)
#' @param weight Vector of observation weights or multiplicities
#' @param ty Numeric matrix containing lower and upper truncation limits
#' @param nty Number of columns in ty
#' @param tcodes Integer vector of truncation codes (see details)
#' @param n Number of rows in y
#' @param dscrat Numeric scratch vector (length = 3 * n + 2)
#' @param scrat Numeric scratch array (length = max((7 * n), maxmsd * (maxmsd - 1) / 2))
#' @param iscrat Integer scratch array (length = 6 * n + 4)
#' @param iprint Print level for debug dump
#' @param maxit Maximum number of iterations for s-c algorithm
#' @param tol Desired estimation accuracy (0 < \code{tol} < 0.1)
#' @param maxmsd Maximum \code{m} for which the full information matrix estimates of the
#'        standard errors can be computed
#' @param nstart If \code{nstart = 0} set automatic start values, otherwise send down \code{nstart}
#'        values in \code{prob} for restart
#'
#' @return A \code{list} of length 6
#' \itemize{
#'  \item{p}{Numeric vector of lower limits of intervals for the cdf estimate (length = n + 1)}
#'  \item{q}{Numeric vector of upper limits of intervals for the cdf estimate (length = n + 1)}
#'  \item{prob}{Numeric vector of cdf estimates corresponding to intervals \code{p} and \code{q}}
#'  \item{m}{Actual length of \code{p}, \code{q}, and \code{prob} (depends on data)}
#'  \item{pchmax}{Max change in last iteration (if greater than tol, 0.0 if Kaplan-Meier was used)}
#'  \item{ier}{Error code (see details)}
#' }
#'              0     no error
#'              1     n <= 0 on input
#'              2     ny not equal to 1 or 2
#'              3     nty not between 0 and 2
#'              4     tol outside range (0, 0.1)
#'              6     censor code out of range 0 to 4
#'              7     y(i,1) != y(i,2) in a type 1, 2, or 3 observation
#'              8     y(i,1) <  y(i,2) in type 4 obs
#'              9     ny=1 but type 4 obs found
#'             10     tcode outside range 1 to 4
#'             11     tcode = 1, 2, or 3 but tyl != tyu
#'             12     backwards truncation interval
#'             12     ty(i,1) < ty(i,2) in type 4 obs
#'             13     only 1 col of truncation values, code 4 found
#'             14     not enough data to estimate distribution
#'                       (e.g., all right censored observations)
#'             15     nstart>0 does not agree with computed m
#'             16     observation not within the truncation interval
#'            *21     product-limit estimate could not be computed
#'                    directly and maxmsd was too small to allow the
#'                    full information matrix to be computed
#'                    an approximation was computed under the assumption
#'                    that the individual hazard
#'                    estimates are uncorrelated
#'            *22     information matrix not positive definite
#'            *23     only one non-zero s probability
#'
#'         * signifies warning message only
#'
#' @details
#' \itemize{
#'  \item{0}{dummy observation}
#'  \item{1}{exact failure time}
#'  \item{2}{right censored observation}
#'  \item{3}{left censored observation}
#'  \item{4}{interval or group censored observation}
#'  \item{5}{exact failure time recoded as a small interval}
#'  }
#' \itemize{
#'  \item{1}{no truncation}
#'  \item{2}{right truncated observation}
#'  \item{3}{left truncated observation}
#'  \item{4}{interval truncated observation}
#'  }
#'
#'  \code{iprint = 0} for no debug output, if > 0 dump setup and every iprint iteration,
#'  \code{iprint = 1} gives the maximum amount of output, \code{iprint = 10} is a good choice to debug
WQMCDFEST <- function(y, ny, codes, weight, ty, nty, tcodes, n, nstart, dscrat, scrat, iscrat, kprint, maxit, tol, maxmsd, p, q, prob, sd, m, pchmax, lsd, ier) {
    .Call(`_SMRD2_WQMCDFEST`, y, ny, codes, weight, ty, nty, tcodes, n, nstart, dscrat, scrat, iscrat, kprint, maxit, tol, maxmsd, p, q, prob, sd, m, pchmax, lsd, ier)
}

#' Wrapper for wqm_cpoints
#' @details Need wrapper to be able to call from 
#'          debugging mail program
WQMCPOINTS <- function(y, ny, codes, codes2, weight, weight2, ty, nty, tcodes, n, nstart, dscrat, scrat, iscrat, iprint, maxit, tol, maxmsd, p, q, prob, sd, m, pchmax, lsd, ier, ilcv, iucv, iltv, iutv, iorder, xlcen, xrcen, fail, xltru, xrtru, ys, pgrad, s, probd) {
    .Call(`_SMRD2_WQMCPOINTS`, y, ny, codes, codes2, weight, weight2, ty, nty, tcodes, n, nstart, dscrat, scrat, iscrat, iprint, maxit, tol, maxmsd, p, q, prob, sd, m, pchmax, lsd, ier, ilcv, iucv, iltv, iutv, iorder, xlcen, xrcen, fail, xltru, xrtru, ys, pgrad, s, probd)
}

#' Wrap for wqm_flike to vectorize the 
#' computation of the likelihood
WQMEVLIKE <- function(xold, y, cen, wt, ty, tcodes, gamthr, nrow, ny, nty, nparm, intcpt, nter, thetav, lfix, ntheta, fpfxxx, upcen, kdist, thetb, thetg, xnew, diag, tmat, rv1, vcvg, kprinp, xlike, ier) {
    .Call(`_SMRD2_WQMEVLIKE`, xold, y, cen, wt, ty, tcodes, gamthr, nrow, ny, nty, nparm, intcpt, nter, thetav, lfix, ntheta, fpfxxx, upcen, kdist, thetb, thetg, xnew, diag, tmat, rv1, vcvg, kprinp, xlike, ier)
}

WQMMLESSS <- function(ivec, rvec, nrow, nparm, x, y, cen, wt, msftgm, ty, tcodes, lfix, e, dscrat, iscrat, theta, fsder, vcv, r, res, fv, dev, ipxnew, iprv1, ipdiag, iptmat, ipthb, ipthg, ipfsd, ipvcvb, ipvcvg, ipnext, itd, itf, ied, iw, ivd, ivcvd, ivcvdd, iir, ijc) {
    .Call(`_SMRD2_WQMMLESSS`, ivec, rvec, nrow, nparm, x, y, cen, wt, msftgm, ty, tcodes, lfix, e, dscrat, iscrat, theta, fsder, vcv, r, res, fv, dev, ipxnew, iprv1, ipdiag, iptmat, ipthb, ipthg, ipfsd, ipvcvb, ipvcvg, ipnext, itd, itf, ied, iw, ivd, ivcvd, ivcvdd, iir, ijc)
}

WQMMRR2 <- function(y, cen, wt, iscrat, rscrat, nrownw, thetamrr) {
    .Call(`_SMRD2_WQMMRR2`, y, cen, wt, iscrat, rscrat, nrownw, thetamrr)
}

#' Wrapper for wqm_points
WQMPOINTS <- function(q, p, prob, sd, lsd, m, yplot, pplot, sdplot, mplot) {
    .Call(`_SMRD2_WQMPOINTS`, q, p, prob, sd, lsd, m, yplot, pplot, sdplot, mplot)
}

WQMSPHIALL <- function(phib, phibm, phis, phip, n, z, idist) {
    .Call(`_SMRD2_WQMSPHIALL`, phib, phibm, phis, phip, n, z, idist)
}

#' Computes the sample MCF and its robust sample 
#' variance. Created by Huaiqing Wu & William Q. 
#' Meeker, Iowa State University
XXMCF <- function(numrecurr, timeofrecurr, krecurrid, dcost, muniqrecurr, tuniq, apoint, lnumrecurr, delta, nunitsgroups, wpoint, nwindows, twindowsl, twindowsu, wcounts, inwindowj, muhat, varhat, dbar, iordl, iordu, iorder, iscrat) {
    .Call(`_SMRD2_XXMCF`, numrecurr, timeofrecurr, krecurrid, dcost, muniqrecurr, tuniq, apoint, lnumrecurr, delta, nunitsgroups, wpoint, nwindows, twindowsl, twindowsu, wcounts, inwindowj, muhat, varhat, dbar, iordl, iordu, iorder, iscrat)
}

